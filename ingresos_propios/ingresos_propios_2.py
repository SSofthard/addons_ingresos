# -*- coding: utf-8 -*-
##############################################################################
#
#    OpenERP, Open Source Management Solution
#    Copyright (C) 2004-2010 Tiny SPRL (<http://tiny.be>).
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
# Generated by the OpenERP plugin for Dia !

from lxml import etree
import math
import pytz
import urlparse

import openerp
from openerp.osv.expression import get_unaccent_wrapper

from openerp import tools, api
from openerp.osv import fields, osv
from openerp.tools.translate import _
from datetime import datetime, date, time, timedelta
from dateutil.relativedelta import *

class partner(osv.osv):
    """Registro de laas Personas y Empresas"""
    _name = 'res.partner'
    _inherit="res.partner"
    
    _columns = {
        'parque': fields.boolean('Activo'),
    }

class registro_parque(osv.osv):
    """Registro de los Parques"""
    _name = 'registro_parque'
    _inherits = {'res.partner': 'partner_id'}
    
    def cantidad_etiqueta_parque(self, cr, uid, ids, name, arg, context=None):
        res = dict(map(lambda x: (x,0), ids))
        inventario_etiqueta_obj=self.pool.get('ip.correlativo.generar')
        for parque in self.browse(cr, uid, ids, context=context):
            res[parque.id]=res[parque.id]+len(inventario_etiqueta_obj.search(cr, uid,[('state', 'in',['asignado']),('parque_id', '=', parque.id)],context=context))
        return res
    
    def cantidad_boleto_parque(self, cr, uid, ids, name, arg, context=None):
        res = dict(map(lambda x: (x,0), ids))
        inventario_boletos_obj=self.pool.get('ip.inventario.boletos.parque')
        for boleto in self.browse(cr, uid, ids, context=context):
            inventario_id=inventario_boletos_obj.search(cr, uid,[('parque_id', '=', boleto.id)],context=context)
            for inventario_boleto_parque in inventario_boletos_obj.browse(cr,uid,inventario_id,context=context):
                res[boleto.id]=res[boleto.id]+inventario_boleto_parque.existente
        return res

    @api.multi
    def _get_image(self, name, args):
        return dict((p.id, tools.image_get_resized_images(p.image1)) for p in self)

    @api.one
    def _set_image(self, name, value, args):
        return self.write({'image1': tools.image_resize_image_big(value)})

    @api.multi
    def _has_image(self, name, args):
        return dict((p.id, bool(p.image1)) for p in self)
    
    _columns = {
        'partner_id':fields.many2one('res.partner', 
                'Registro del Parque', 
                required=True, 
                ondelete='cascade'
                ),
        'tipo_parque_id': fields.many2one('tipo_parque', 'Tipo de Parque', required=True, help='Tipo de Parque'),
        'ciudad': fields.char('Ciudad', size=50, required=True, help='Nombre de la ciudad del parque'),
        'redi_id': fields.many2one('redi', 'REDI', required=True, help='Region Estrategica de Defensa Integral'),
        #~ 'estado_id': fields.many2one('estados', 'Estado', required=True, help='Nombre del Estado'),
        #~ 'municipio_id': fields.many2one('municipios', 'Municipio', required=True, help='Nombre del Municipio'),
        #~ 'parroquia_id': fields.many2one('parroquias', 'Parroquia', required=True, help='Nombre de la Parroquia'),
        #~ 'sector': fields.char('Sector', size=25, help='Nombre del Sector'),
        #~ 'calle_avenida': fields.char('Calle/Avenida', size=100, help='Nombre de calle avenida'),
        #~ 'referencia': fields.char('Punto de Referencia', size=100, help='Punto de Referencia'),
        'reg_amb_dpto_ids': fields.one2many('reg_amb_dpto', 'registro_parque_id', 'Estructura', help='Relacion de los ambitos a los parques'),
        'image1': fields.binary("Image",
            help="This field holds the image used as avatar for this contact, limited to 1024x1024px"),
        'image_medium': fields.function(_get_image, fnct_inv=_set_image,
            string="Medium-sized image", type="binary", multi="_get_image",
            store={
               
                'conc.registro_embarcacion': (lambda self, cr, uid, ids, c={}: ids, ['image1'], 10),
            },
            help="Medium-sized image of this contact. It is automatically "\
                 "resized as a 128x128px image, with aspect ratio preserved. "\
                 "Use this field in form views or some kanban views."),
        'image_small': fields.function(_get_image, fnct_inv=_set_image,
            string="Small-sized image", type="binary", multi="_get_image",
            store={
                'conc.registro_embarcacion': (lambda self, cr, uid, ids, c={}: ids, ['image1'], 10),
            },
            help="Small-sized image of this contact. It is automatically "\
                 "resized as a 64x64px image, with aspect ratio preserved. "\
                 "Use this field anywhere a small image is required."),
        'has_image': fields.function(_has_image, type="boolean"),
        'cant_stock':fields.function(cantidad_boleto_parque,'Boletos Generados', type='integer',),    
        'cant_etiquetas':fields.function(cantidad_etiqueta_parque,'etiquetas Asignadas', type='integer'),
    }
    

    _defaults = {
        'parque':True,
        'is_company':True,
        'rif':'G-20000632-3',
    }
    
    @api.multi
    def onchange_type(self, is_company):
        value = {'title': False}
        #~ print value
        if is_company:
            value['use_parent_address'] = False
            domain = {'title': [('domain', '=', 'partner')]}
        else:
            domain = {'title': [('domain', '=', 'contact')]}
        #~ print 'bkdjfkjhfjdhfjkdf', value
        return {'value': value, 'domain': domain}
    
    def create(self,cr,uid,values,context=None):
        values.update({
            'image':values['image1']})
        return super(registro_parque,self).create(cr,uid,values,context=context)
    
class regiones(osv.osv):
    """Registro de Regiones"""
    _name = 'regiones'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Regiones', size=100, required=True, help='Nombre de la Region'),
    }
    
regiones()

class ambitos(osv.osv):
    """Registro de Ambitos"""
    _name = 'ambitos'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Nombre del Ambito', size=100, required=True, help='Nombre del Ambito'),
        'region_id': fields.many2one('regiones', 'Nombre de la Region', required=True, help='Relacion de la Region con el Ambito'),
    }
    
ambitos()

class departamentos(osv.osv):
    """Registro de Departamentos"""
    _name = 'departamentos'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Departamento', size=100, required=True, help='Nombre del Departamento'),
        'ambito_id': fields.many2one('ambitos', 'Ambito', required=True, help='Relacion del ambito con el Departamento'),
    }
    
departamentos()

class tipo_parque(osv.osv):
    """Registro de Tipo de Parque"""
    _name = 'tipo_parque'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Tipo de Parque', size=100, required=True, help='Nombre del Tipo si es Parque o Monumento'),
    }
    
tipo_parque()

class redi(osv.osv):
    """Registro de REDI"""
    _name = 'redi'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('REDI', size=50, required=True, help='Nombre de la REDI'),
    }
    
redi()

class estados(osv.osv):
    """Registro de Estados"""
    _name = 'estados'
    _rec_name = 'estado'
    
    _columns = {
        'estado': fields.char('Estado', size=100, required=True, help='Nombre del Estado'),
        'codigo': fields.char('Codigo', size=3, required=True, help='Codigo del Estado'),
        'redi_id': fields.many2one('redi', 'REDI', required=True, help='Relacion de la REDI con Estado'),
    }
    
estados()

class municipios(osv.osv):
    """Registro de Municipios"""
    _name = 'municipios'
    _rec_name = 'municipio'
    
    _columns = {
        'municipio': fields.char('Municipio', size=100, required=True, help='Nombre del Municipio'),
        'codigo': fields.char('Codigo', size=3, required=True, help='Codigo del Estado'),
        'estado_id': fields.many2one('estados', 'Estado', required=True, help='Relacion del Estado con Municipio'),
    }
    
municipios()

class parroquias(osv.osv):
    """Registro de parroquias"""
    _name = 'parroquias'
    _rec_name = 'parroquia'
    
    _columns = {
        'parroquia': fields.char('Parroquias', size=100, required=True, help='Nombre de la parroquia'),
        'codigo': fields.char('Codigo', size=3, required=True, help='Codigo del Estado'),
        'municipio_id': fields.many2one('municipios', 'Municipio', required=True, help='Relacion del Municipio con la parroquia'),
    }
    
parroquias()

class genero(osv.osv):
    """Registro de Genero"""
    _name = 'genero'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('GÃ©nero', size=20, required=True, help='Nombre del Genero: Masculino, Femenino'),
    }
    
genero()

class estado_civil(osv.osv):
    """Registro del Estado Civil"""
    _name = 'estado_civil'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Estado Civil', size=25, required=True, help='Nombre del Estado Civil: Soltero, Casado, etc...'),
    }
    
estado_civil()

class persona(osv.osv):
    """Registro de Persona"""
    _name = 'persona'
    _rec_name = 'nombre'
    #_rec_name = 'apellido'
    #_rec_name = 'cedula'
    
    _columns = {
        'nombre': fields.char('Nombres', size=100, required=True, help='Nombres de la persona que se registra'),
        'apellido': fields.char('Apellidos', size=100, required=True, help='Apellidos de la persona que se registra'),
        'cedula': fields.char('Cedula', size=10, required=True, help='Cedula de la persona que se registra'),
        'fecha_nac': fields.date('Fecha de Nacimiento', required=True, help='Fecha de Nacimiento de la persona que se registra'),
        'genero_id': fields.many2one('genero', 'Genero', required=True, help='Genero de la Persona'),
        'estado_civil_id': fields.many2one('estado_civil', 'Estado Civil', required=True, help='Estado Civil que posee la Persona'),
        'correo': fields.char('Correo', size=50, help='Correo Electronico de la persona'),
        'ciudad': fields.char('Ciudad', size=50, required=True, help='Ciudad de la persona que se registra'),
        'redi_id': fields.many2one('redi', 'REDI', required=True, help='Region Estrategica de Defensa Integral'),
        'estado_id': fields.many2one('estados', 'Estado', required=True, help='Estado al que pertenece la persona'),
        'municipio_id': fields.many2one('municipios', 'Municipio', required=True, help='Nombre del Municipio que pertenece la persona'),
        'parroquia_id': fields.many2one('parroquias', 'Parroquia', required=True, help='Nombre de la Parroquia que pertenece la Persona'),
        'sector': fields.char('Sector', size=50, help='Sector al que pertenece la persona'),
        'calle_avenida': fields.char('Calle/Avenida', size=100, help='Nombre de la calle o avenida de la direccion'),
        'referencia': fields.char('Punto de Referencia', size=100, help='Punto de Referencia de la direccion'),
        'casa_apto': fields.char('Casa/Apartamento', size=100, help='Nombre de la casa o Apartamento'),
        'numero': fields.char('Numero de Casa/Apto', size=10, help='Numero de la Casa o Apartamento'),
        'telefono_ids': fields.one2many('telefono_persona', 'persona_id', 'Telefono'),
    }
    
persona()

class reg_amb_dpto(osv.osv):
    """Relacion de Region Ambito Dptos"""
    _name = 'reg_amb_dpto'
    #_rec_name = 'region_id'
    _rec_name = 'ambito_id'
    #_rec_name = 'dptos_id'
    #_rec_name = 'registro_parque_id'
    
    _columns = {
        'region_id': fields.many2one('regiones', 'RegiÃ³n', required=True, help='Relacion de la Region con el Parque'),
        'ambito_id': fields.many2one('ambitos', 'Ambito', required=True, help='Relacion del Ambito con el Parque'),
        'dptos_id': fields.many2one('departamentos', 'Departamento', required=True, help='Relacion del Departamento con el parque'),
        'registro_parque_id': fields.many2one('registro_parque', 'Parque/Monumento'),
    }
    
reg_amb_dpto()

class telefono_persona(osv.osv):
    """Registro de Telefonos"""
    _name = 'telefono_persona'
    #_rec_name = 'persona_id'
    #_rec_name = 'tlf_id'
    #_rec_name = 'numero'
    
    _columns = {
        'persona_id': fields.many2one('persona', 'Nombre'),
        'tlf_id': fields.many2one('tipo_telefono', 'Tipo de Telefono', required=True, help='Tipo del Telefono que posee la persona'),
        'numero': fields.char('Numero', size=15, required=True, help='Numero de telefono que posee la persona'),
    }
    
telefono_persona()

class tipo_telefono(osv.osv):
    """Registro de Tipo de Telefono"""
    _name = 'tipo_telefono'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Tipo de Telefono', size=20, required=True, help='Tipo de telefono que existen'),
    }
    
tipo_telefono()

class juridico_natural(osv.osv):
    """Registro de laas Personas y Empresas"""
    _name = 'juridico_natural'
    #~ _inherit="res.partner"
    _inherits = {'res.partner': 'partner_id'}
    #~ _rec_name = 'rif'
    
    @api.multi
    def onchange_type(self, is_company):
        value = {'title': False}
        if is_company:
            value['use_parent_address'] = False
            domain = {'title': [('domain', '=', 'partner')]}
        else:
            domain = {'title': [('domain', '=', 'contact')]}
        return {'value': value, 'domain': domain}
        
    def onchange_address(self, cr, uid, ids, use_parent_address, parent_id, context=None):
        def value_or_id(val):
            """ return val or val.id if val is a browse record """
            return val if isinstance(val, (bool, int, long, float, basestring)) else val.id
        result = {}
        if parent_id:
            if ids:
                partner = self.browse(cr, uid, ids[0], context=context)
                if partner.parent_id and partner.parent_id.id != parent_id:
                    result['warning'] = {'title': _('Warning'),
                                         'message': _('Changing the company of a contact should only be done if it '
                                                      'was never correctly set. If an existing contact starts working for a new '
                                                      'company then a new contact should be created under that new '
                                                      'company. You can use the "Discard" button to abandon this change.')}
            if use_parent_address:
                parent = self.browse(cr, uid, parent_id, context=context)
                address_fields = self._address_fields(cr, uid, context=context)
                result['value'] = dict((key, value_or_id(parent[key])) for key in address_fields)
        else:
            result['value'] = {'use_parent_address': False}
        return result
        
    @api.multi
    def onchange_state(self, state_id):
        if state_id:
            state = self.env['res.country.state'].browse(state_id)
            return {'value': {'country_id': state.country_id.id}}
        return {}
        
    
    _columns = {
        #~ 'nombre': fields.char('Nombre', size=150, required=True, help='Nombre de la Persona Natural o Juridica que se va a Registrar'),
        'rif': fields.char('RIF', size=20, required=True, help='Numero del RIF de la Persona Natural o Juridica que se va a Registrar'),
        'correo': fields.char('Correo', size=50, help='Correo Electronico de la Persona Natural o Juridica que se va a Registrar'),
        'objeto': fields.text('Objeto', required=True, help='Objeto de la Persona Natural o Juridica que se va a Registrar'),
        'redi_id': fields.many2one('redi', 'REDI', required=True, help='Region Estrategica de Defensa Integral'),
        'estado_id': fields.many2one('estados', 'Estado', required=True, help='Estado que pertenece la Persona Natural o Juridica que se va a Registrar'),
        'municipio_id': fields.many2one('municipios', 'Municipio', required=True, help='Municipio que pertenece la Persona Natural o Juridica que se va a Registrar'),
        'parroquia_id': fields.many2one('parroquias', 'Parroquia', required=True, help='Parroquia que pertenece la Persona Natural o Juridica que se va a Registrar'),
        'partner_id': fields.many2one('res.partner', 'Parner', ondelete="cascade", required=True,),
        'sector': fields.char('Sector', size=50, help='Sector de la Persona Natural o Juridica que se va a Registrar'),
        'referencia': fields.char('Punto de Referencia', size=100, help='Punto de Referencia  que pertenece la Persona Natural o Juridica que se va a Registrar'),
        'telefonos_ids': fields.one2many('telefono_jur_nat', 'juridico_natural_id', 'Telefonos', help='Relacion de la Persona Natura o Juridica con los Tlefonos'),
        'documentos_ids': fields.one2many('documentos', 'juridico_natural_id', 'Documentos', help='Relacion de la Persona Natura o Juridica con los Documentos'),
        #~ 'estatus_nombre': fields.selection([('activo', 'Activo'), ('no_activo', 'No Activo')], 'Estatus', help="Se colocara el Estatus de Fundo Zamorano (Activo y No Activo).", required=True, states={'activo': [('readonly', False)]}),
    }
    
juridico_natural()

class telefono_jur_nat(osv.osv):
    """Registro de los Telefonos"""
    _name = 'telefono_jur_nat'
    _rec_name = 'numero'
    
    _columns = {
        'juridico_natural_id': fields.many2one('juridico_natural', 'Empresa/Persona', help='Relacion de la Persona Natural o Juridica'),
        'tlf_id': fields.many2one('tipo_telefono', 'Tipo de Telefono', required=True, help='Tipo de Telefono que se va a Registrar'),
        'numero': fields.char('Numero', size=20, required=True, help='Numero de Telefono de la Persona Natural o Juridica que se registra'),
    }
    
telefono_jur_nat()

class documentos(osv.osv):
    """Registro de Documentos"""
    _name = 'documentos'
    _rec_name = 'nombre'
    
    _columns = {
        'juridico_natural_id': fields.many2one('juridico_natural', 'Empresa/Persona', help='Documentos que posee la Persona Natural o Juridica: RIF, Solvencias, etc'),
        'nombre': fields.char('Nombre del Documento', size=100, required=True, help='Nombre que posee el Documento'),
        'descripcion': fields.char('Descripcion', size=200, help='Descripcion del Documento'),
        'fecha_exp': fields.date('Fecha de Expedicion', required=True, help='Fecha de Expedicion que posee el Documento'),
        'fecha_venc': fields.date('Fecha de Venciemiento', help='Fecha de Vencimiento del Documento '),
    }
    
documentos()

class acount_invoice(osv.osv):
    _inherit="account.invoice"
    
    _columns = {
        'isconcesion': fields.boolean('Concesion'),
        'ismora': fields.boolean('Mora'),
    }

class concesiones(osv.osv):
    """Registro de Concesiones"""
    _name = 'concesiones'
    _inherits = {'product.template': 'product_id',}
    _inherit = ['mail.thread']
    _description = 'Registro de Concesiones'
        
    def function_unidad_trib(self,cr,uid,ids,field_name,arg,context=None):
        res={}
        account_config_obj=self.pool.get('account.config.settings')
        config = account_config_obj.get_default_ut(cr, uid,fields)
        for id in ids:
            res[id]=config['unidad_tributaria']
        return res 
   
   
    def function_calculo_pago(self,cr,uid,ids,field_name,arg,context=None):
        res={}
        for r in self.browse(cr,uid,ids):
            res[r.id]=r.pago_mensual*r.unidad_tributaria
        return res
    
    def get_default_unidad_trib(self, cr, uid,fields,context=None):
        account_config_obj=self.pool.get('account.config.settings')
        res = account_config_obj.get_default_ut(cr, uid,fields)
        return res['unidad_tributaria']
        
    def acount_tax_exento(self,cr,uid,context=None):
        
        tax_obj=self.pool.get('account.tax')
        tax_id=tax_obj.search(cr, uid, [('name','=','Exento')])
        return [[6,0,[tax_id[0]]]]
        
    def _get_attachment_number(self, cr, uid, ids, fields, args, context=None):
        res = dict.fromkeys(ids, 0)
        for app_id in ids:
            res[app_id] = self.pool['ir.attachment'].search_count(cr, uid, [('res_model', '=', 'concesiones'), ('res_id', '=', app_id)], context=context)
        return res
    
    
    _columns = {
        'product_id':fields.many2one('product.template', 'Product Category', required=True, ondelete='cascade'),
        #~ 'alias_id': fields.many2one('mail.alias', 'Alias', ondelete="restrict", required=True, help="Comunicacion"),
        'tipo_actividad_id': fields.many2one('tipo_actividad', 'Tipo de Actividad', required=True, help='Tipo de Actividad que Practica la Concesion'),
        'fecha_inicio': fields.date('Fecha de Inicio', required=True, help='Fecha de Inicio de la Concesion'),
        'fecha_fin': fields.date('Fecha Final', required=True, help='Fecha Final de la Concesion'),
        'fecha_aviso': fields.date('Fecha de Aviso', required=True, help='Fecha de Aviso para que el Sistema le Indique cuando sera proximo a vencerse la Concesion'),
        'pago_mensual': fields.float('Unidad Tibutaria Mensual',  help='Pago del Canon Mensual que tendra la Concesion'),
        #~ 'account_invoice_id': fields.integer('Relacion de la Factura con la Concesion'),
        'datos_contrato': fields.text('Datos del Contrato', required=False, help='Datos del Contrato u Observaciones que se puedan presentar'),
        'espacio': fields.char('Espacio a Utilizar', size=300,  help='Numero en metros cuadrados que utilizara la persona Natural o Juridica para la Concesion'),
        'unidad_tributaria': fields.function(function_unidad_trib,'Unidad Tributaria',  type="float", readonly=True, help='Monto de la Unidad Tributaria'),
        'pago_mens': fields.function(function_calculo_pago,'Total a Cancelar Mensual en BsF.',  type="float", readonly=True, help='Pago Mensual....'),
        'registro_parque_id': fields.many2one('registro_parque', 'Parque o Monumento', required=True, help='Parque o Monumento donde esta la Concesion que se registra'),
        'juridico_natural_id': fields.many2one('juridico_natural', 'RazÃ³n Social', help='Persona Natural o Juridica la cual posee la Concesion'),
        'active': fields.boolean('Activo'),
        'partner_id': fields.many2one('res.partner', 'Empresa/Persona', ondelete="cascade", required=True),
        'company_id': fields.many2one('res.company', 'CompaÃ±ia',),
        'factura_por_generar_ids': fields.one2many('conc.facturas.por.generara', 'concesion_id', 'RelaciÃ³n Factura por Generar'),
        'documentos_ids': fields.one2many('documentos', 'juridico_natural_id', 'Documentos', help='Relacion de la Persona Natura o Juridica con los Documentos'),
        'attachment_number': fields.function(_get_attachment_number, string='Number of Attachments', type="integer"),
        'state': fields.selection([
            ('en_proceso', 'En Proceso'),
            ('cancel', 'Cancelada'),
            ('procesada', 'Procesada'),
            ], 'Status', readonly=True, copy=False, help="", select=True),
    }
    _defaults = {
        'active':True,
        #~ 'isconcesion':True,
        'unidad_tributaria':get_default_unidad_trib,
        'company_id': 1,
        'list_price': 0,
        'state': 'en_proceso',
        'taxes_id':acount_tax_exento,
    }
    
    def action_get_attachment_tree_view(self, cr, uid, ids, context=None):
        model, action_id = self.pool.get('ir.model.data').get_object_reference(cr, uid, 'base', 'action_attachment')
        action = self.pool.get(model).read(cr, uid, action_id, context=context)
        action['context'] = {'default_res_model': self._name, 'default_res_id': ids[0]}
        action['domain'] = str(['&', ('res_model', '=', self._name), ('res_id', 'in', ids)])
        return action
        
    
    def cacular_monto(self,cr,uid,ids,unidad_tributaria,pago_mensual,fecha_inicio,fecha_fin,context=None):
        res={}
        if(pago_mensual>0):
            if(fecha_inicio and fecha_fin):
                a,m,d=fecha_inicio.split('-')
                fecha_inicio = date(int(a),int(m),int(d))
                a,m,d=fecha_fin.split('-')
                fecha_fin = date(int(a),int(m),int(d))
                tiempo=relativedelta(fecha_fin,fecha_inicio)
            i = 1
            while i <= int(tiempo.years):
                tiempo.months=tiempo.months+12
                i += 1
            i = 1
            while i <= int(tiempo.months):
                fecha_inicio=fecha_inicio+relativedelta(months=+1)
                i += 1
            resultado=float(unidad_tributaria)*float(pago_mensual)
            res['total']=resultado
            res['list_price']=resultado
        return {'value':res}
        
    
    def create_fact_conc(self, cr, uid, ids, context=None):
        if isinstance(ids,(int,long)):
            ids=[ids]
        hoy=date.today()
        order_line_obj=self.pool.get('sale.order.line')
        account_invoice_obj=self.pool.get('account.invoice')
        concesiones_ids=self.search(cr, uid, [('state', 'in',['en_proceso','en_deuda'])])
        concesion_data=self.browse(cr,uid,concesiones_ids, context=context)
        for h in concesion_data:
            invoices_ids=account_invoice_obj.search(
                                                    cr, 
                                                    uid, 
                                                    [
                                                    ('partner_id', '=',h.partner_id.id),
                                                    ('date_due','<=',hoy),
                                                    ('state', '=','draft'),
                                                    ],order =  "date_due asc")
            acount_invoice_data=account_invoice_obj.browse(cr,uid,invoices_ids, context=context)
            for r in acount_invoice_data:
                account_invoice_obj.signal_workflow(cr,uid,[r.id],'invoice_open')
        #~ sale_advance_payment_inv_obj=self.pool.get('sale.advance.payment.inv')
        #~ account_config_obj=self.pool.get('account.config.settings')
        #~ unidad_tributaria = account_config_obj.get_default_ut(cr, uid,fields)
        #~ sale_order_obj = self.pool.get('sale.order')
        #~ concesiones_ids=self.search(cr, uid, [('state', 'in',['en_proceso','en_deuda'])])
        #~ concesion_data=self.browse(cr,uid,concesiones_ids, context=context)
        #~ facturas_generara_obj=self.pool.get('conc.facturas.por.generara')
        #~ for r in concesion_data:
            #~ facturas_generara_ids=facturas_generara_obj.search(
                                                                #~ cr, 
                                                                #~ uid, 
                                                                #~ [('concesion_id', '=',r.id),
                                                                 #~ ('fecha_facturar','<=',hoy),
                                                                 #~ ('estado','=','por_generar')
                                                                #~ ])
            #~ facturas_generara_data=facturas_generara_obj.browse(cr,uid,facturas_generara_ids, context=context)
            #~ tax= [t.id for t in r.taxes_id]
            #~ for f in facturas_generara_data:
                #~ sale_order_vals=[]
                #~ order_line_vals=[]
                #~ total=0.0
                #~ sale_order_vals={
                    #~ 'warehouse_id':r.company_id.id,
                    #~ 'client_order_ref':f.nombre,
                    #~ 'partner_id':r.partner_id.id
                    #~ }
                #~ order_line_vals.append(list((0,False,{
                    #~ 'company_id':r.company_id.id,
                    #~ 'product_uos_qty':r['uos_coeff'],
                    #~ 'product_id':r.product_id.id,
                    #~ 'product_uom':r['uom_id'].id,
                    #~ 'route_id': False,
                    #~ 'price_unit':(r.pago_mensual*unidad_tributaria['unidad_tributaria']),
                    #~ 'product_uom_qty': 1,
                    #~ 'delay': r['sale_delay'],
                    #~ 'product_uos':r.product_id and r.product_id.id,
                    #~ 'th_weight': 0,
                    #~ 'product_packaging': False,
                    #~ 'discount': 0,
                    #~ 'tax_id': [[6, False, [tax[0]]]],
                    #~ 'name': f.nombre
                    #~ })))
                #~ sale_order_vals.update({'order_line': order_line_vals})
                #~ orden_id = sale_order_obj.create(cr, uid, sale_order_vals, context=context)
                #~ sale_order_obj.action_button_confirm(cr, uid,[orden_id])
                #~ wizard_context={
                           #~ 'lang': 'es_VE',
                           #~ 'tz': False,
                           #~ 'uid': uid,
                           #~ 'active_model': sale_order_obj,
                           #~ 'search_disable_custom_filters': True,
                           #~ 'active_ids': [orden_id],
                           #~ 'active_id': orden_id
                            #~ }
                #~ sale_advance_payment_inv_obj_id=sale_advance_payment_inv_obj.create(cr, uid, [], context=context)
                #~ sale_advance_payment_inv_obj.create_invoices(cr,uid,[sale_advance_payment_inv_obj_id],wizard_context)
                #~ retorno=sale_order_obj.action_view_invoice(cr, uid,[orden_id])
                #~ acccount_invoice_id=retorno.get('res_id')
                #~ account_invoice_obj=self.pool.get('account.invoice')
                #~ account_invoice_obj.signal_workflow(cr, uid, [acccount_invoice_id], 'invoice_open')
                #~ facturas_generara_obj.write(cr, uid, [f.id], {'estado': 'generada'})
        return True
        
        
    def boton_cancelar(self, cr, uid, ids, context=None):
        cap_vis_obj=self.pool.get('config_captacion_visitantes')
        cap_vis_obj.get_default_cap_vis(cr, uid, ids, fields,context)
        return self.write(cr, uid, ids, {'state': 'cancel'})
    
    #~ def cancel_reservation(self,cr,uid,ids,context=None):
        #~ self.write(cr, uid, ids, {'state':'cancel'},context=context)
        #~ return True
        
        
        
    ########################################LIDER########################################################
    
    # metodo para general las vfacturas por facturar..... lider por favor analiza el metodo y lo que no entiendas me preguntas si dominas esta parte 
    #~ subes de nivel gracias, viernes 7:30 OJO revisa bien el resultado que este generando lo que queremos y quita todo los comentarios
   
   
   ##################################################################################################
        
    def facturas_por_realizar(self,cr,uid,ids,fecha_inicio,fecha_fin,unidad_tributaria,pago_mensual,context=None):
        
        if isinstance(ids,(int,long)):
            ids=[ids]
        res={}
        datos=[]
        hoy=str(date.today())
        if cmp(fecha_inicio,fecha_fin)==1:
                raise osv.except_osv(
                    ('Error!'),
                    (u'La Fecha Final %s no puede\
                     ser menor a la Fecha Inicial\
                      %s'% (fecha_fin,fecha_inicio)))
        
         
        if(fecha_inicio and fecha_fin and pago_mensual):
            format = "%B %Y"
            a,m,d=fecha_inicio.split('-')
            fecha_inicio = date(int(a),int(m),int(d))
            a,m,d=fecha_fin.split('-')
            fecha_fin = date(int(a),int(m),int(d))
            tiempo=relativedelta(fecha_fin,fecha_inicio)
            if tiempo.months<=0:
                raise osv.except_osv(
                    ('Error!'),
                    (u'La ConcesiÃ³n tiene que ser \
                     Mayoy a un Mes \
                      %s , %s'% (fecha_inicio,fecha_fin)))
            i = 1
            while i <= int(tiempo.years):
                tiempo.months=tiempo.months+12
                i += 1
            i = 1
            while i <= int(tiempo.months):
                fecha_inicio=fecha_inicio+relativedelta(months=+1)
                fecha_inicio2 = fecha_inicio.strftime(format)
                datos.append([0,False,{'nombre': 'A Pagar: '+str(fecha_inicio2), 'fecha_facturar':fecha_inicio, 'ut_id':unidad_tributaria, 'pago_mensual':pago_mensual, 'estado': 'por_generar', 'concesion_id': False}])
                i += 1
            resultado=(unidad_tributaria*pago_mensual)
        else:
            res={
                'fecha_fin':''
            }
            return {
         'value':res
            }
        attrs={'fecha_fin':"{'readonly': [('fecha_inicio','=',False)]}"}
        res={
                'factura_por_generar_ids':datos,
                'pago_mens':resultado,
                    }
        return {
         'value':res,
         'attrs':attrs
            }

    
        
    def validar_fecha(self, cr, uid, ids, context=None):
        hoy=str(date.today())
        for r in self.browse(cr,uid,ids):
            if cmp(r.fecha_inicio,r.fecha_fin)==1:
                raise osv.except_osv(
                    ('Error!'),
                    (u'Revise bien que La Fecha Final %s no puede\
                     ser menor a la fecha Inicial\
                      %s'% (r.fecha_fin,r.fecha_inicio)))
            if cmp(r.fecha_inicio,r.fecha_aviso)==1:
                raise osv.except_osv(
                    ('Error!'),
                    (u'La Fecha de Aviso %s\
                     no puede ser Menor a la fecha Inicial %s'
                     %(r.fecha_aviso,r.fecha_inicio)))
            if cmp(r.fecha_aviso,r.fecha_fin)==1:
                raise osv.except_osv(
                    ('Error!'),
                    (u'La Fecha de Aviso %s\
                     no puede ser Mayor a la fecha Final %s'
                     %(r.fecha_aviso,r.fecha_inicio)))
        return True
    
    #~ Metodo donde se realiza el codigo automatico de el producto en concesiones
    
    def create_borrador_factura(self, cr, uid, ids,values,context=None):
        # Variable inicializada con la fecha actual del servidor
        hoy=date.today()
        #~ sale_advance_payment_inv_obj=self.pool.get('sale.advance.payment.inv')
        # Instanciamos un Objeto para obtener el valor de la unidad tributaria
        account_config_obj=self.pool.get('account.config.settings')
        fact_generar_obj=self.pool.get('conc.facturas.por.generara')
        # Creamos una variable con la cual vamos a obtener el valor de la UT y almacenarlo alli para utilizarlo
        unidad_tributaria = account_config_obj.get_default_ut(cr, uid,fields)
        # Instanciamos un Objeto de la clase account.invoice.line
        acount_line_obj=self.pool.get('account.invoice.line')
        # Instanciamos un Objeto de la clase account.invoice
        account_invoice_obj=self.pool.get('account.invoice')
        # Instanciamos un Objeto de la clase account.account
        account_obj=self.pool.get('account.account')
        # Realizamos un search para obtener los ids con las condiciones dadas dentro del mismo
        account_ids=account_obj.search(cr, 
                                        uid, 
                                        [('code', '=',1122001),
                                         ('name','=','CUENTAS POR COBRAR CLIENTES'),
                                        ])
        # a los ids del search le hacemos un browse para obtener los datos especificos de esa busqueda
        account_data=account_obj.browse(cr,uid,account_ids, context=context)
        # Realizamos un search para obtener los ids con las condiciones dadas dentro del mismo
        concesiones_ids=self.search(cr, uid, [('state', 'in',['en_proceso','en_deuda'])])
        # a los ids del search le hacemos un browse para obtener los datos especificos de esa busqueda
        concesion_data=self.browse(cr,uid,concesiones_ids, context=context)
        # Este for se realiza para recorrerel resultado de la data y obtener el Tax o Impuesto
        for t in concesion_data:
            tax=t['taxes_id']
        # con esta variable ejecutamos el metodo de facturas_por_realizar 
        #~ valores=self.facturas_por_realizar(cr,uid,ids,values['fecha_inicio'],values['fecha_fin'],unidad_tributaria['unidad_tributaria'],values['pago_mensual'],context=context)
        # Este for lo utilizamos para recorrer los valores que llenamos en el O2M factura_por_generar_ids
        for s in t.factura_por_generar_ids:
            # Declaramos dos variables tipo Tuplas para llenarlas mas adelante
            acount_invoice_vals=[]
            acount_line_vals=[]
            print 'jhjjjhjhjhjhjhj'
            print float(s.ut_id)*float(s.pago_mensual)
            print float(s.ut_id)*float(s.pago_mensual)
            print float(s.ut_id)*float(s.pago_mensual)
            # Aqui llenamos una variable que contendra los valores de account invoiced
            acount_invoice_vals={
                'name':values['name'],
                'reference':values['name'],
                'account_id':account_data.id,
                'partner_id':context['default_partner_id'],
                'date_due':s.fecha_facturar,
                'user_id':uid,
                
                #~ despues de la migracion
                
                #~ 'amount_total':unidad_tributaria['unidad_tributaria']*context['default_pago_mensual'],
                #~ 'amount_untaxed':unidad_tributaria['unidad_tributaria']*context['default_pago_mensual'],
                
                'amount_total':float(s.ut_id)*float(s.pago_mensual),
                'amount_untaxed':float(s.ut_id)*float(s.pago_mensual),
                'isconcesion':True,
                }
            # Realizamos un search para obtener los ids con las condiciones dadas dentro del mismo
            account_line_ids=account_obj.search(cr, 
                                    uid, 
                                    [('code', '=',5111002),
                                     ('name','=','VENTAS NACIONALES AL DETAL'),
                                    ])
            # Realizamos un browse para obtener los valores del search antes realizado
            account_line_data=account_obj.browse(cr,uid,account_line_ids, context=context)
            # Aqui Adicionamos la variable que contendra los valores de account invoiced line
            acount_line_vals.append(list((0,False,{
                'uos_id': 1, 
                'account_id': account_line_data.id, 
                #~ 'price_unit': unidad_tributaria['unidad_tributaria']*context['default_pago_mensual'], 
                'price_unit': float(s.ut_id)*float(s.pago_mensual), 
                'invoice_line_tax_id': [[6, False, [tax.id]]], 
                'product_id': ids[0], 
                'name': values['name'], 
                'account_analytic_id': False, 
                })))
            # Aqui actualizamos los valores que trae esta variable y le pasamos en el atributo invoice_line los valores adicionados 
            acount_invoice_vals.update({'invoice_line': acount_line_vals})
            # Mediante esta variable que inicializamos al comienzo llamos al metodo para crear la factura
            account_invoice_id=account_invoice_obj.create(cr, uid, acount_invoice_vals, context=context)
            fact_generar_obj.write(cr, uid, [s.id], {'account_invoice_id': account_invoice_id})
        return True
        
    def editar_concesion(self,cr,uid,ids,context=None):
        res=[]
        ut=[]
        ids_invoice=[]
        pago=[]
        for r in self.browse(cr,uid,ids):
            for n in r.factura_por_generar_ids:
                ids_invoice.append(n.account_invoice_id)
                ut.append(n.ut_id)
                pago.append(n.pago_mensual)
            res.append(ut)
            res.append(ids_invoice)
            res.append(pago)
        return res
        
    def write(self, cr, uid, ids, vals, context=None):
        super(concesiones, self).write(cr, uid, ids, vals, context=context)
        editar_conc=self.editar_concesion(cr, uid, ids, context=context)
        n=0
        account_invoice_obj=self.pool.get('account.invoice')
        for i in editar_conc[1]:
            ut=editar_conc[0]
            pago=editar_conc[2]
            ut=ut[n]
            pago=pago[n]
            total=float(ut)*float(pago)
            account_invoice_line_obj=self.pool.get('account.invoice.line')
            account_invoice_line_ids=account_invoice_line_obj.search(cr, uid, [('invoice_id','=',[i])])
            account_invoice_obj.write(cr, uid, [i], {'amount_total': total,'amount_untaxed':total,})
            account_invoice_line_obj.write(cr, uid, account_invoice_line_ids, {'price_unit': total,})
            n+=1
        return editar_conc
        
        
    def calcular_mora(self, cr, uid, ids, values,context=None):
        
        hoy=date.today()
        valor_mora=0.01
        account_obj=self.pool.get('account.account')
        account_line_ids=account_obj.search(cr, 
                                    uid, 
                                    [('code', '=',9212004),
                                     ('name','=','INTERESES VARIOS'),
                                    ])
        account_config_obj=self.pool.get('account.config.settings')
        unidad_tributaria = account_config_obj.get_default_ut(cr, uid,fields)
        fact_generar_obj=self.pool.get('conc.facturas.por.generara')
        account_invoice_obj=self.pool.get('account.invoice')
        acount_line_obj=self.pool.get('account.invoice.line')
        concesiones_ids=self.search(cr, uid, [('state', '=','en_proceso')])
        concesion_data=self.browse(cr,uid,concesiones_ids, context=context)
        for r in concesion_data:
            cfg_account_invoice_ids=[]
            fact_generar_ids=fact_generar_obj.search(cr,uid,[('concesion_id','=',r.id)])
            fact_generar_data=fact_generar_obj.browse(cr,uid,fact_generar_ids)
            for fg in fact_generar_data:
                cfg_account_invoice_ids.append(fg.account_invoice_id)
            tax= [t.id for t in r.taxes_id]
            account_invoice_ids=account_invoice_obj.search(cr, 
                                            uid, 
                                            [('state', 'in',['open','draft']),
                                             ('id', 'in',cfg_account_invoice_ids),
                                             ('date_due','<=',hoy),
                                             ('isconcesion','=',True),
                                            ],
                                            order = "date_due asc")
            account_invoice_data=account_invoice_obj.browse(cr,uid,account_invoice_ids, context=context)
            array_nuevo_total={}
            for h in account_invoice_data:
                nombre='Mora por Factura: ', h.internal_number
                acount_invoice_vals=[]
                acount_line_vals=[]
                account_invoice_line_ids=acount_line_obj.search(cr,uid,[('invoice_id','=',h.id)])
                account_invoice_line_data=acount_line_obj.browse(cr,uid,account_invoice_line_ids,context=context)
                mora_acum=0.00
                for mora in array_nuevo_total:
                    print mora
                    mora_acum+=array_nuevo_total[mora]
                    print mora_acum
                total_mora=(mora_acum+h.amount_total)*valor_mora
                array_nuevo_total[h.id]=total_mora+h.amount_total
                if h.ismora==False:
                    acount_invoice_vals={
                        'amount_total':array_nuevo_total[h.id],
                        'amount_untaxed':array_nuevo_total[h.id],
                        'residual':array_nuevo_total[h.id],
                        'ismora':True,
                        }
                    acount_line_vals={
                        'uos_id': 1, 
                        'invoice_id': h.id, 
                        'company_id': 1, 
                        'account_id': account_line_ids[0], 
                        'partner_id': r.partner_id.id, 
                        'price_unit': total_mora, 
                        'price_subtotal': total_mora, 
                        'invoice_line_tax_id': [[6, False, [tax[0]]]], 
                        #~ 'product_id': r.product_id.id, 
                        'name': str(nombre),
                        'account_analytic_id': False,
                        }
                    acount_line_obj.create(cr, uid, acount_line_vals, context=context)
                    account_invoice_obj.write(cr, uid, h.id, acount_invoice_vals, context=context)
        return True
    
    def create(self,cr,uid,values,context=None):
        print values
        
        
        
        values.update({
            'name':self.pool.get('ir.sequence').get(cr,uid,'seq.concesion'),
            
            })
        
        concesion_id=super(concesiones,self).create(cr,uid,values,context=context)
        product_template_id=self.browse(cr,uid,concesion_id).product_id.id
        product_obj=self.pool.get('product.product')
        product_id=product_obj.search(cr,uid,[('product_tmpl_id','=',product_template_id)],context=None)
        self.create_borrador_factura(cr,uid,product_id,values,context=context);
        
        return concesion_id
    
    def _check_dates(self, cr, uid, ids, context=None):
        for leave in self.read(cr, uid, ids, ['fecha_inicio', 'fecha_fin'], context=context):
            if leave['fecha_inicio'] and leave['fecha_fin']:
                if leave['fecha_inicio'] > leave['fecha_fin']:
                    return False
        return True
        
    _constraints = [
        (validar_fecha, ' ', ['fecha_inicio', 'fecha_fin']), 
    ]
   
concesiones()

class tipo_actividad(osv.osv):
    """Registro de Tipo de Actividad"""
    _name = 'tipo_actividad'
    _rec_name = 'nombre'
    
    _columns = {
        'nombre': fields.char('Tipo de Actividad', size=50, required=True, help='Nombre del tipo de Actividad'),
    }
    
tipo_actividad()

