# -*- coding: utf-8 -*-
##############################################################################
#

#
##############################################################################
# Generated by the OpenERP plugin for Dia !
from openerp.osv import fields, osv
from datetime import datetime, date, time, timedelta
import time
from openerp.tools import DEFAULT_SERVER_DATE_FORMAT, DEFAULT_SERVER_DATETIME_FORMAT


class account_tax(osv.osv):
    _inherit='account.tax'
    
    _columns = {
        'taxes_2_id': fields.many2many('ip.rendicion.boletos.line', 'rendicion_order_tax_2', 'taxe_id_2','rendicion_tax_id_2', 'Impuestos', readonly=True, states={'draft': [('readonly', False)]}),
    }

class rendicion_boletos(osv.Model):
    _name = "ip.rendicion.boletos"
    _inherit = ['mail.thread']
    
    def _amount_line_tax(self, cr, uid, line, context=None):
        val = 0.0
        for c in self.pool.get('account.tax').compute_all(cr, uid, line.taxe_id, line.price_unit * (1-(line.discount or 0.0)/100.0), line.product_uom_qty, line.product_id, line.rendicion_id.partner_id)['taxes']:
            val += c.get('amount', 0.0)
        return val
    
    def _amount_all_wrapper(self, cr, uid, ids, field_name, arg, context=None):
        """ Wrapper because of direct method passing as parameter for function fields """
        return self._amount_all(cr, uid, ids, field_name, arg, context=context)
    
    def _amount_all(self, cr, uid, ids, field_name, arg, context=None):
        cur_obj = self.pool.get('res.currency')
        res = {}
        for order in self.browse(cr, uid, ids, context=context):
            res[order.id] = {
                'sub_total': 0.0,
                'amount_tax': 0.0,
                'amount_total': 0.0,
            }
            val = val1 = 0.0
            cur = order.pricelist_id.currency_id
            for line in order.rendicion_boletos_line:
                val1 += line.price_subtotal
                val += self._amount_line_tax(cr, uid, line, context=context)
            res[order.id]['amount_tax'] = cur_obj.round(cr, uid, cur, val)
            res[order.id]['sub_total'] = cur_obj.round(cr, uid, cur, val1)
            res[order.id]['amount_total'] = res[order.id]['sub_total'] + res[order.id]['amount_tax']
        return res
    
    def _get_order(self, cr, uid, ids, context=None):
        result = {}
        for line in self.pool.get('ip.rendicion.boletos.line').browse(cr, uid, ids, context=context):
            result[line.rendicion_id.id] = True
        return result.keys()
    
    def verificar_pago(self,cr,uid,ids,field_name,arg,context=None):
        res={}
        records=self.browse(cr,uid,ids)
        account_invoice_obj=self.pool.get('account.invoice')
        for r in records:
            if not r.state=='done':
                if r.acccount_invoice_id:
                    for account_invoice in account_invoice_obj.browse(cr,uid,[r.acccount_invoice_id]):
                        if account_invoice.state=='paid':
                            self.write(cr, uid, ids, {'state':'paid'},context=context)
                            res[r.id]=1
        return res
    
    
    _columns = {
        'partner_id':fields.many2one('res.partner', 'Parque', readonly=True, required=True, states={'draft':[('readonly', False)]}),
        'pricelist_id':fields.many2one('product.pricelist', 'Price List', required=True, readonly=True, states={'draft':[('readonly', False)]}, help="Pricelist for current reservation. "),
        'partner_invoice_id':fields.many2one('res.partner', 'Invoice Address', readonly=True, states={'draft':[('readonly', False)]}, help="Invoice address for current reservation. "),
        'partner_order_id':fields.many2one('res.partner', 'Ordering Contact', readonly=True, states={'draft':[('readonly', False)]}, help="The name and address of the contact that requested the order or quotation."),
        'partner_shipping_id':fields.many2one('res.partner', 'Delivery Address', readonly=True, states={'draft':[('readonly', False)]}, help="Delivery address for current reservation. "),
        'date_order':fields.datetime('Fecha de rendicion', required=True, readonly=True, states={'draft':[('readonly', False)]}),
        'note': fields.text('Terminos y condiciones'),
        
        
        'sub_total': fields.function(_amount_all_wrapper,  string='Sub-Total',
            store={
                'ip.rendicion.boletos': (lambda self, cr, uid, ids, c={}: ids, ['rendicion_boletos_line'], 10),
                'ip.rendicion.boletos.line': (_get_order, ['price_unit', 'taxe_id', 'discount', 'product_uom_qty'], 10),
            },multi='sums', help="The tax amount."),
        'amount_tax': fields.function(_amount_all_wrapper,  string='Impuestos',
            store={
                'ip.rendicion.boletos': (lambda self, cr, uid, ids, c={}: ids, ['rendicion_boletos_line'], 10),
                'ip.rendicion.boletos.line': (_get_order, ['price_unit', 'taxe_id', 'discount', 'product_uom_qty'], 10),
            },multi='sums', help="The tax amount."),
        'amount_total': fields.function(_amount_all_wrapper,  string='Total',
            store={
                'ip.rendicion.boletos': (lambda self, cr, uid, ids, c={}: ids, ['rendicion_boletos_line'], 10),
                'ip.rendicion.boletos.line': (_get_order, ['price_unit', 'taxe_id', 'discount', 'product_uom_qty'], 10),
            },multi='sums', help="The tax amount."),
        
        'state': fields.selection([('draft', 'Borrador'), ('confirm', 'Confirmado'),('invoiced', 'Facturado'),('paid', 'Pagado'), ('cancel', 'Cancelado'), ('done', 'Validado')], 'Estado', readonly=True),
        'currency_id': fields.related('pricelist_id', 'currency_id', type="many2one", relation="res.currency", string="Currency", readonly=True, required=True),
        'user_id': fields.many2one('res.users', 'Usuario', states={'draft': [('readonly', False)], 'sent': [('readonly', False)]}, select=True, track_visibility='onchange'),
        'acccount_invoice_id':fields.integer('Id de la factura',readonly=True,),
        'rendicion_boletos_line':fields.one2many('ip.rendicion.boletos.line','rendicion_id', 'Rendir Boleto', help='Detalles del boleto a rendir.'),
        'verificar_pago':fields.function(verificar_pago,int='float',string='Verificar Pago'),
        'paymen_ids':fields.many2many('account.move.line', 'pago_ids', 'ren_var_id','Pagos',),
    }
    
    
    _defaults = {
        'state': lambda *a: 'draft',
        'date_order': lambda *a: time.strftime('%Y-%m-%d %H:%M:%S'),
        'user_id': lambda obj, cr, uid, context: uid,
    }
    
    def onchange_pricelist_id(self, cr, uid, ids, pricelist_id, rendicion_boletos_line, context=None):
        context = context or {}
        if not pricelist_id:
            return {}
        value = {
            'currency_id': self.pool.get('product.pricelist').browse(cr, uid, pricelist_id, context=context).currency_id.id
        }
        if not rendicion_boletos_line or rendicion_boletos_line == [(6, 0, [])]:
            return {'value': value}
        warning = {
            'title': _('Pricelist Warning!'),
            'message' : _('If you change the pricelist of this order (and eventually the currency), prices of existing order lines will not be updated.')
        }
        return {'warning': warning, 'value': value}

    def onchange_partner_id(self, cr, uid, ids, partner_id):
        if not partner_id:
            return {'value':{'partner_invoice_id': False, 'partner_shipping_id':False, 'partner_order_id':False}}
        partner_obj = self.pool.get('res.partner')
        addr = partner_obj.address_get(cr, uid, [partner_id], ['delivery', 'invoice', 'contact'])
        pricelist = partner_obj.browse(cr, uid, partner_id).property_product_pricelist.id
        return {'value':{'partner_invoice_id': addr['invoice'], 'partner_order_id':addr['contact'], 'partner_shipping_id':addr['delivery'], 'pricelist_id': pricelist,'rendicion_boletos_line':''}}

    
        return True
    def button_dummy(self, cr, uid, ids, context=None):
        return True

    def draft_rendicion(self,cr,uid,ids):
        self.write(cr, uid, ids, {'state':'draft'})
        return True
        
    def confirmed_rendicion(self,cr,uid,ids,context=None):
        self.write(cr, uid, ids, {'state':'confirm'},context=context)
        return True
        
    def cancel_rendicion(self,cr,uid,ids,context=None):
        self.write(cr, uid, ids, {'state':'cancel'},context=context)
        return True
        
    def rendicion_terminada(self,cr,uid,ids,context=None):
        for i in self.browse(cr, uid, ids, context=context):
            for r in i.rendicion_boletos_line:
                if r.prefijo.upper():
                    boletos_obj=self.pool.get('ip.boletos')
                    boletos_id=boletos_obj.search(cr,uid,[('product_id','=',int(r.product_id))])
                    boletos_datos=boletos_obj.browse(cr,uid,boletos_id,context=context)
                    registro_parque_obj=self.pool.get('registro_parque')
                    registro_parque_id=registro_parque_obj.search(cr,uid,[('partner_id','=',int(i.partner_id))])
                    registro_parque_datos=registro_parque_obj.browse(cr,uid,registro_parque_id,context=context)
                    inventario_boleto_parque_obj=self.pool.get('ip.inventario.boletos.parque')
                    inventario_boleto_parque_ids=inventario_boleto_parque_obj.search(cr,uid,[('producto_id','=',int(boletos_datos['id'])),('parque_id','=',int(registro_parque_datos['id'])),('prefijo','=',str(r.prefijo.upper())),])
                    inventario_boleto_parque_datos=inventario_boleto_parque_obj.browse(cr,uid,inventario_boleto_parque_ids,context=context)
                    cantidad=inventario_boleto_parque_datos['existente']-r.product_uom_qty
                    inventario_boleto_parque_obj.write(cr, uid, inventario_boleto_parque_ids, {'existente': cantidad},context=context)
                    self.write(cr, uid, ids, {'state':'done'},context=context)
        return True
    
    
    
    def rendicion_pagar(self, cr, uid, ids, context=None):
        account_invoice_obj=self.pool.get('account.invoice')
        account_line_obj=self.pool.get('account.invoice.line')
        account_obj=self.pool.get('account.account')
        #~ Realizamos un search para obtener los ids con las condiciones dadas dentro del mismo
        account_ids=account_obj.search(cr, 
                                        uid, 
                                        [('code', '=',1122001),
                                         ('name','=','CUENTAS POR COBRAR CLIENTES'),
                                        ])
        #~ a los ids del search le hacemos un browse para obtener los datos especificos de esa busqueda
        account_data=account_obj.browse(cr,uid,account_ids, context=context)
        # Realizamos un search para obtener los ids con las condiciones dadas dentro del mismo
        account_line_ids=account_obj.search(cr, 
                                        uid, 
                                        [('code', '=',5111002),
                                         ('name','=','VENTAS NACIONALES AL DETAL'),
                                        ])
        # Realizamos un browse para obtener los valores del search antes realizado
        account_line_data=account_obj.browse(cr,uid,account_line_ids, context=context)
        for rendicion in self.browse(cr, uid, ids, context=context):
            account_invoice_vals=[]
            account_line_vals=[]
            for line in rendicion.rendicion_boletos_line:
                tax= [t.id for t in line.taxe_id]
                print rendicion.partner_id.id
                print rendicion.partner_id.id
                print rendicion.partner_id.id
                #~ Aqui Adicionamos la variable que contendra los valores de account invoiced line por cada servicio
                account_line_vals.append(list((0,False,{
                    'uos_id':1, 
                    'account_id': account_line_data.id, 
                    'price_unit': line.price_unit, 
                    'quantity': line.product_uom_qty,
                    'invoice_line_tax_id': [[6, False, [tax[0]]]], 
                    'product_id': line.product_id and line.product_id.id, 
                    'name': line.name, 
                    'account_analytic_id': False, 
                    })))
             #~ Aqui llenamos una variable que contendra los valores de account invoiced
            account_invoice_vals={
                #~ 'name':reservation['reservation_no'],
                #~ 'reference':reservation['reservation_no'],
                'account_id':account_data.id,
                'partner_id':rendicion.partner_id.id,
                'date_due':date.today(),
                'user_id':uid,
                'amount_total':rendicion['amount_total'],
                'amount_untaxed':rendicion['sub_total'],
                'isawning':True,
                }
            # Aqui actualizamos los valores que trae esta variable y le pasamos en el atributo invoice_line los valores adicionados 
            account_invoice_vals.update({'invoice_line': account_line_vals})
            # Mediante esta variable que inicializamos al comienzo llamos al metodo para crear la factura
            acccount_invoice_id=account_invoice_obj.create(cr, uid, account_invoice_vals, context=context)
            #~ con esto manipulo el workflow de account invoice para validar la factura 
            account_invoice_obj.signal_workflow(cr, uid, [acccount_invoice_id], 'invoice_open')
            #~ con esto pulso el boton de registrar pago y el por defecto me devuelve la vista de cancelar la 
            #~ factura
            vista_pago=account_invoice_obj.invoice_pay_customer(cr,uid,[acccount_invoice_id])
            self.write(cr, uid, ids, {'state':'invoiced','acccount_invoice_id':acccount_invoice_id},context=context)
            return vista_pago
    
    
    def pagar_rendicion(self, cr, uid, ids, context=None):
        account_invoice_obj=self.pool.get('account.invoice')
        for rendicion in self.browse(cr, uid, ids, context=context):
                for account_invoice in account_invoice_obj.browse(cr,uid,[rendicion.acccount_invoice_id]):
                    if not account_invoice.state=='paid':
                        vista_pago=account_invoice_obj.invoice_pay_customer(cr,uid,[rendicion.acccount_invoice_id]) 
                        return vista_pago
        return True
        
    def imprimir_rendicion(self, cr, uid, ids, context=None):
        for rendicion in self.browse(cr,uid,ids,context=context):
                acccount_invoice_id=rendicion.acccount_invoice_id
        return self.pool['report'].get_action(cr, uid, [acccount_invoice_id], 'account.report_invoice', context=context)


class rendicion_boletos_line(osv.Model):
    _name = "ip.rendicion.boletos.line"
    _rec_name="partner_id"
    
    
    def sub_total(self, cr, uid, ids, field_name, arg, context=None):
        res={}
        tax_obj = self.pool.get('account.tax')
        cur_obj = self.pool.get('res.currency')
        res = {}
        if context is None:
            context = {}
        for line in self.browse(cr, uid, ids, context=context):
           
            price = line.price_unit * (1 - (line.discount or 0.0) / 100.0)
            res[line.id] = price*line.product_uom_qty
        return res
    def cargar_partner(self, cr, uid, ids, field_name, arg, context=None):
        res={}
        return res
    
    _columns = {
        'partner_id':fields.many2one('res.partner', 'Parque', readonly=True, required=True, states={'draft':[('readonly', False)]}),
        'prefijo': fields.char('prefijo',required=True,),
        'rendicion_id':fields.many2one('ip.rendicion.boletos', 'Rendir Boletos'),
        'product_id': fields.many2one('product.product', 'Boleto', domain=[('sale_ok', '=', True),('isticket', '=', True),], readonly=True, states={'draft': [('readonly', False)]}, ondelete='restrict'),
        'name': fields.text('Descripcion', required=True, readonly=True, states={'draft': [('readonly', False)]}),
        'product_uom_qty': fields.float('Cantidad', required=True, readonly=True, states={'draft': [('readonly', False)]}),
        'price_unit': fields.float('Precio Unitario', required=True,  readonly=True, states={'draft': [('readonly', False)]}),
        'taxe_id': fields.many2many('account.tax', 'rendicion_order_tax', 'rendicion_tax_id', 'taxe_id', 'Impuestos', readonly=True, states={'draft': [('readonly', False)]}),
        'price_subtotal': fields.function(sub_total, string='Subtotal',),
        'discount': fields.float('Descuento (%)', readonly=True, states={'draft': [('readonly', False)]}),
        'state': fields.selection(
                [('cancel', 'Cancelled'),('draft', 'Draft'),('confirmed', 'Confirmed'),('exception', 'Exception'),('done', 'Done')],
                'Status', required=True, readonly=True, copy=False,),
    }
    
    
    
    _defaults = {
        'state': 'draft',
        'price_unit': 0.0,
        'product_uom_qty': 1,
        'product_uos_qty': 1,
    }
    
    
    def product_id_change(self, cr, uid, ids, product_id, partner_id,context=None):
        if not partner_id:
            raise osv.except_osv(('Parque no definido!'), ('Seleccione un parque.'))
        res={}
        if product_id:
            product_product_obj=self.pool.get('product.product')
            product_product_id=product_product_obj.search(cr,uid,[('id','=',product_id)],context=context)
            product_product_datos=product_product_obj.browse(cr,uid,product_product_id,context=context)
            res={
                'price_unit': product_product_datos['list_price'],
                'taxe_id':product_product_datos['taxes_id'],
                'name':product_product_datos['name'],
                'partner_id':partner_id
            }
        return {'value':res}
    
    

    
    
    def create(self,cr,uid,vals,context=None):
        vals.update({
            'prefijo':vals['prefijo'].upper()
            })
        if vals['prefijo'].upper():
            boletos_obj=self.pool.get('ip.boletos')
            boletos_id=boletos_obj.search(cr,uid,[('product_id','=',vals['product_id'])])
            boletos_datos=boletos_obj.browse(cr,uid,boletos_id,context=context)
            registro_parque_obj=self.pool.get('registro_parque')
            registro_parque_id=registro_parque_obj.search(cr,uid,[('partner_id','=',int(vals['partner_id']))])
            registro_parque_datos=registro_parque_obj.browse(cr,uid,registro_parque_id,context=context)
            inventario_boleto_parque_obj=self.pool.get('ip.inventario.boletos.parque')
            inventario_boleto_parque_id=inventario_boleto_parque_obj.search(cr,uid,[('producto_id','=',int(boletos_datos['id'])),('parque_id','=',int(registro_parque_datos['id'])),('prefijo','=',str(vals['prefijo'].upper())),])
            inventario_boleto_parque_datos=inventario_boleto_parque_obj.browse(cr,uid,inventario_boleto_parque_id,context=context)
            cantidad=0
            if len (inventario_boleto_parque_id)==1:
                for i in inventario_boleto_parque_datos:
                    cantidad+=i.existente
                if cantidad<vals['product_uom_qty']:
                    raise osv.except_osv(
                        ('Error de cantidad'),
                        ('La cantidad '+str(vals['product_uom_qty'])+' no esta dentro del rango de boletos asignados.'))
            #~ else:
                #~ raise osv.except_osv(
                        #~ ('Error '),
                        #~ ('No existe la cantidad '+str(vals['product_uom_qty'])+' disponible con el prefijo '+vals['prefijo'].upper()))
        return super(rendicion_boletos_line, self).create(cr, uid, vals, context=context)
        
    
    
